# 计划：修复 TestAdd 中的周计算错误

## 问题分析
在 `cascade_add_test.go` 中，周添加 (`AddWeek`) 的测试失败：
- `AddWeek(2)`: 预期 `2024-02-13` (周二), 实际 `2024-02-12` (周一)。
- `AddWeek(-1)`: 预期 `2024-01-23` (周二), 实际 `2024-01-22` (周一)。

## 原因推测
基准时间 `2024-01-30` 是 **周二**。
`thru` 包可能有周对齐（Week Alignment）逻辑。如果 `AddWeek` 隐式地将日期对齐到周起始日（默认为周一），那么：
- 2024-01-30 (周二) 对齐到周一 -> 2024-01-29。
- 2024-01-29 + 2周 (14天) -> 2024-02-12 (周一)。(实际结果吻合)
- 2024-01-29 - 1周 (7天) -> 2024-01-22 (周一)。(实际结果吻合)

## 代码验证
在 `opus.go` 的 `applyRel` 中：
```go
	case Week:
		d -= int(w-startsAt+7) % 7
		d += n * 7
```
这证实了 `Week` 操作（即 `AddWeek` 使用的 `fromNoalign` 模式调用的 `applyRel`）会**强制将日期对齐到周起始日**。
这与 `AddYear` 只是简单加年份不同，`AddWeek` 具有副作用：它不仅仅是 `AddDay(7*n)`，而是 `StartOfWeek().AddDay(7*n)`。

## 修复策略
更新测试预期以反映当前的实际行为（对齐到周一）。

- `AddWeek(2)`:
    - 2024-01-30 (周二) -> 对齐到周一 (2024-01-29)。
    - +14天 -> 2024-02-12 (周一)。
    - 预期: `2024-02-12 15:04:05`。
- `AddWeek(-1)`:
    - 2024-01-30 (周二) -> 对齐到周一 (2024-01-29)。
    - -7天 -> 2024-01-22 (周一)。
    - 预期: `2024-01-22 15:04:05`。

## 实施步骤
修改 `cascade_add_test.go` 中的断言值。

```go
	// 6. 周与大参数
	// AddWeek 会先对齐到周起始日(周一)，再偏移。
	// 2024-01-30(周二) -> 2024-01-29(周一) + 14天 = 2024-02-12
	assert(t, base.AddWeek(2), "2024-02-12 15:04:05", "AddWeek(2)")
	// 2024-01-30(周二) -> 2024-01-29(周一) - 7天 = 2024-01-22
	assert(t, base.AddWeek(-1), "2024-01-22 15:04:05", "AddWeek(-1)")
```
