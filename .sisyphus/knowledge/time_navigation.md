# Aeon Time Navigation 核心逻辑详考

本文档记录 Aeon 时间导航引擎（`cascade` & `opus`）的底层实现细节，旨在精确描述各时间单位在不同模式下的计算行为。

---

## 1. 核心运行逻辑

### 1.1 模式划分 (Go vs. Start/End)
- **Go 模式 (`c.goMode == true`)**：
  - **定位语义**：执行单位寻址，但**保留**当前时间分量的精度。
  - **对齐行为**：不执行 `align()`。
  - **示例**：`GoYear(5)` 定位于本年代第 5 年，但保留原有的月、日、时、分、秒、纳秒。
- **SE (Start/End) 模式 (`c.goMode == false`)**：
  - **定位语义**：执行单位寻址，并准备进行边界对齐。
  - **对齐行为**：循环结束后强制执行 `align()`。
    - `Start*`：下级单位全部归零（1月、1日、0时...）。
    - `End*`：下级单位全部置满（12月、31日、23时...，纳秒至 .999999999）。

### 1.2 绝对值协议 (`c.abs`)
- 当 `c.abs == true` 时（通常由顶级方法如 `Go(2025)` 触发），单位计算逻辑跳过容器寻址，直接设置为目标数值。

---

## 2. 绝对定位逻辑详考 (`applyAbs`)

### 2.1 世纪 (Century)
- **计算基础**：`y` (年份)
- **c.abs == true**：`y = n * 100` (直达指定世纪)。
- **寻址模式**：容器为“千年 (1000年)”。
  - `n > 0`：当前千年的第 `n` 个世纪。
  - `n < 0`：当前千年的倒数第 `n` 个世纪（计算：`y + 1000` 后寻址）。
- **Go 模式**：`y = (y - y%1000) + (y % 10) + n*100`。
  - **效果**：保留该世纪内的“年代”和“年位”。例如 `2021` 年 `GoCentury(1)` 变为 `2121`。
- **SE 模式**：
  - `n == 0`：`y = y - y%100` (保持当前世纪起始)。
  - `n != 0`：`y = (y - y%1000) + n*100` (定位到指定世纪起始)。

### 2.2 年代 (Decade)
- **计算基础**：`y` (年份)
- **c.abs == true**：`y = n * 10`。
- **寻址模式**：容器为“世纪 (100年)”。
- **Go 模式**：`y = (y - y%100) + (y % 10) + n*10`。
  - **效果**：保留该年代内的“年位”。例如 `2021` 年 `GoDecade(5)` 变为 `2051`。
- **SE 模式**：
  - `n == 0`：`y = y - y%10`。
  - `n != 0`：`y = (y - y%100) + n*10`。

### 2.3 年份 (Year)
- **寻址模式**：容器为“年代 (10年)”。
- **Go 模式**：`y = (y - y%10) + n`。
  - `n < 0` 时先 `y += 10` 执行倒数寻址。
- **SE 模式**：
  - `n == 0`：保持当前年份。
  - `n != 0`：执行与 Go 模式相同的年代内寻址。

### 2.4 季度 (Quarter)
- **计算基础**：`m` (月份)
- `n > 0`：`m = (n-1)*3 + 1` (Q1->1月, Q2->4月...)。
- `n < 0`：`m = (5+n-1)*3 + 1` (-1->10月, -4->1月)。
- `n == 0`：`m -= (m-1)%3` (回到当前季度首月)。

### 2.5 月份 (Month)
- **父单位依赖**：
  - **如果 p == Quarter**：在季度内寻址。
    - `n > 0`：`m = 季度起始月 + n - 1`。
    - `n < 0`：`m = 季度起始月 + 3 + n`。
  - **常规情况**：
    - `n > 0`：`m = n`。
    - `n < 0`：`m = 13 + n`。

### 2.6 周 (Week - 月内周)
- **寻址模式**：容器为“月”。
- **n > 0**：定位到月内第几周。
- **n < 0**：定位到倒数第几周。
- **Go 模式**：
  - **n = 0**：原地保留，不执行任何跳转。
  - **保持星期几**：计算目标周周首后，补偿回原始的 `Weekday` 偏移量：`d += int(w - sw + 7) % 7`。
  - **效果**：`GoWeek(1)` 将跳转到目标周，但保留当前的星期（如周六跳到目标周的周六）。
- **SE 模式**：
  - **对齐周首**：定位到目标周周首，不执行偏移补偿。
  - **后续行为**：由级联结束后的 `align()` 负责归零或置满。

### 2.7 月周 (MonthWeek)
- **n = 0 (Go模式)**：原地保留 (`break`)。
- **模式 A (默认)**：寻找月内第 N 个特定的周起始日。
- **模式 B (Ordinal)**：
  - `n > 0`：`d = 1 + (n-1)*7` (月首偏移)。
  - `n < 0`：`d = 当月总天数 + (n+1)*7` (月末偏移)。
- **级联效应**：如果后续级联了 `Weekday`，且开启了 `Ordinal` 标志，`Weekday` 将从当前 `d` 处开始寻找目标星期。
- **注意**：目前 `MonthWeek` 在 `Go` 模式下暂未引入 `Week` 单元那样的“保持星期几”偏移补偿。

### 2.8 年周 (YearWeek)
- **锚点逻辑**：
  - **常规**：锚点 1月1日。
  - **ISO**：锚点 1月4日（确保第一周至少包含 4 天）。
- **n = 0**：**[待优化]** 目前 `n=0` 仍会强制对齐到周首。
- **Go 模式**：**[待优化]** 目前暂未实现“保持星期几”的偏移补偿。

### 2.9 星期 (Weekday)
- **pN 级联感知**：
  - 如果上级是 `MonthWeek` 且开启了 `Ordinal`：
    - `pN > 0` (正向序数)：从当前 `d` **向后**寻找第一个目标星期。
    - `pN < 0` (逆向序数)：从当前 `d` **向前**寻找第一个目标星期。
- **溢出保护**：如果 `!overflow` 且 `p` 是周相关单位，系统会检查计算出的 `d` 是否跨出了月/年边界。若是，则**强制回滚/前进 7 天**，使其留在当前容器内（这是 Aeon 保证“容器独立性”的关键点）。

### 2.10 亚秒 (Milli/Micro/Nano)
- **计算模型**：`ns = (ns/pf)*pf + n*f`
- **逻辑说明**：`pf` 是上一量级的因数（如 Milli 的 pf 是 1e9，即 1秒）。
- **行为**：保留更高量级的纳秒分量，替换当前量级及其下的分量。

---

## 3. 结果处理

### 3.1 溢出检查 (`final`)
- 如果 `!c.overflow` 且单位在 `Month` 或以上级别，系统会调用 `DaysIn(y, m)`。
- 如果计算出的天数 `d` 超过了该月最大天数，**强制截断**至该月最后一天。

### 3.2 最终对齐 (`align`)
- **Start (fill == false)**：
  - `Year` 级对齐：`m, d, h, mm, sec, ns = 1, 1, 0, 0, 0, 0`
  - `Day` 级对齐：`h, mm, sec, ns = 0, 0, 0, 0`
- **End (fill == true)**：
  - `Year` 级对齐：`m, d, h, mm, sec, ns = 12, 31, 23, 59, 59, 999999999`
  - `Month` 级对齐：`d = DaysIn(y, m)`。
  - `亚秒` 对齐：根据 `u.factor()` 补齐剩余的纳秒空间。
