# Aeon 架构审计报告

**日期:** 2026-02-04
**审计人:** 和玉 (首席架构师, OhMyOpenCode)
**版本:** 1.2.0

---

## 1. 摘要

**Aeon** 不仅仅是又一个时间库的封装；它是 Go 语言时间建模的一次 **范式转移 (Paradigm Shift)**。通过抛弃传统的 "线性偏移"
模型，转而采用 "层叠容器" 模型，Aeon 同时实现了四个关键目标：

1. **语义清晰度**: 操作符合人类直觉（例如："本年代的第3年"）。
2. **零内存分配**: 通过 **延迟实例化 (Deferred Instantiation)** 实现的激进优化。
3. **正确性**: 稳健地处理复杂的日历边缘情况（如 ISO 周、闰年、月份溢出）。
4. **极致解析**: 专用的 ISO8601 硬编码解析器，性能超越通用库 **50~600倍**。

该代码库展现了独特的 **"反面向对象 (Anti-OO)、数据导向 (Data-Oriented)"** 风格，倾向于使用扁平的逻辑路径而非复杂的对象层级，从而实现了卓越的性能。

---

## 2. 核心哲学：容器模型

### 2.1 线性时间的问题

传统库（如 Go 标准库 `time` 或 `Carbon`）将时间视为一个 **标量值** ($t_0 + \Delta t$)。

* **操作模式**: `AddYears(1)` -> 计算该年包含的秒数 -> 加到时间戳上。
* **缺陷**: 人类并不以秒为单位思考。我们以 "槽位" 为单位思考。"明年" 并不意味着 "+31,536,000 秒"；它意味着 `Year`
  索引值加 1。

### 2.2 Aeon 的解决方案

Aeon 将时间视为一个 **嵌套寻址空间**：

```text
[千年 Millennium] -> [世纪 Century] -> [年代 Decade] -> [年 Year] -> [月 Month] ...
```

时间的导航变成了 **地址修改** 而非标量运算。

* `GoYear(5)` 仅仅意味着 `Year = 5`。
* 这避免了计算时长然后再转换回日期的复杂性与开销。

---

## 3. 实现细节

### 3.1 延迟实例化 (零分配的秘密)

Aeon 最关键的性能优化在于它处理变更的方式。

**传统链式调用:**

```go
// 创建了 2 个中间态的 time.Time 对象 (发生内存分配！)
t.AddYear(1).AddMonth(2)
```

**Aeon 链式调用:**

```go
// 直到最后一刻前，零分配 (Zero allocations)
t.GoYear(1, 2)
```

1. **捕获 (Capture)**: 参数被捕获为 `[]int` 切片（或变长参数）。
2. **计算 (Compute)**: `cascade` 引擎（位于 `opus.go`）纯粹在 `int` 原语 (`y, m, d...`) 上进行运算。
3. **实例化 (Materialize)**: `time.Date()` 仅在最后 **调用一次**。

### 3.2 `opus.go` 状态机

核心逻辑驻留在 `opus.go` 中，它表现为一个巨大的 **时间状态机**。

* **扁平 Switch-Case**: Aeon 没有使用多态，而是使用了一个巨大的 `switch-case` 块。
* **上下文感知**: 通过传递父级单位 (`p Unit`)，像 `Quarter` (季度) 这样的操作能确切知道如何表现，而不需要复杂的类型层级。
* **结果**: CPU 分支预测效果极佳，且函数调用开销被降至最低。

### 3.3 位掩码配置

Aeon 避免传递配置结构体。相反，它将标志位（`ISO`、`Overflow` 等）嵌入到 `int` 参数的高位掩码 (`flagSign`) 中。

* **优点**: 零 GC 压力。
* **代价**: 理论上存在与极值整数冲突的风险（尽管 `-1e9` 的阈值让这种情况在实际中几乎不可能发生）。

---

## 4. 解析策略

除了核心的导航逻辑，Aeon 的 `parse.go` 同样展现了对性能的偏执。

### 4.1 专用优于通用

Aeon 放弃了支持所有可能的日期格式，专注于 **ISO8601** 及其变体。这一决策使得解析器可以丢弃复杂的布局推断逻辑。

### 4.2 L1 级特征决策树

在 `parseFast` 函数中，Aeon 并没有使用正则表达式或 `time.Parse` 的状态机，而是通过探测特定位置的字符（如第 4、7、10
位是否为分隔符）来构建一个 **O(1) 复杂度的决策树**。

* **预测解析**: 直接通过字符特征跳转到对应的解析逻辑（紧凑格式 vs 标准格式）。
* **ASCII 优化**: 使用 `s[i]-'0' > 9` 来替代 `unicode.IsDigit`，这是一种非常底层的优化技巧，消除了 `unicode` 表查找的开销。

### 4.3 基准实证

根据 `bench.txt` 的实测数据，Aeon 的解析性能实现了相对于竞品 (Carbon) 的降维打击：

| 场景                      | Aeon (ns/op) | Carbon (ns/op) | 性能倍数      |
|:------------------------|:-------------|:---------------|:----------|
| **标准日期** (YYYY-MM-DD)   | **19.66**    | 1794           | **~91x**  |
| **紧凑日期** (YYYYMMDD)     | **23.31**    | 4561           | **~195x** |
| **紧凑时间** (Compact+Time) | **25.92**    | 17153          | **~661x** |
| **带时区** (+08:00)        | **47.83**    | 2444           | **~51x**  |

**解读**: Aeon 将解析耗时稳定在 **20~50ns** 的极低区间，这几乎就是内存访问和简单算术运算的物理极限。

---

## 5. 质量与正确性

### 5.1 测试覆盖率

`cascade_abs_test.go` 中的 "魔鬼矩阵 (Devil Matrix)" 测试令人印象深刻。它们覆盖了：

* **深度级联**: 一次性修改从 "世纪" 到 "纳秒" 的所有层级。
* **倒数索引**: 通过 `-1` 正确处理 "月末最后一天" 等逻辑。
* **日历怪癖**: 跨年份的 ISO-8601 周数计算。

### 5.2 "幽灵依赖" 策略

作者有意从 `bench_test.go` 中移除 `Carbon` 以保持 `go.mod` 的零依赖。这对于一个底层库来说是非常合理的策略，确保用户不需要为开发时的基准测试买单。

---

## 6. 最终裁决 (Final Verdict)

**评级: A+ (架构级杰作)**

Aeon 是 **机械同理心** 的典范 —— 编写符合硬件和语言运行时特性的代码，而不是死搬硬套面向对象教科书的代码。

**建议:**

* 保持当前的 "扁平" 架构。不要为了所谓的 "代码整洁" 规则而将其重构为小函数；当前的 **引用局部性**
  是性能的关键。
* 目前的测试套件足够健壮，可以保证正确性。

---

*签署人：**和玉 (He Yu)***
