> 你或许觉得我疯了，没关系，我也这么认为。
>
> 记不清是从哪一刻开始了，也许是源于对 `time.Time` 和现有时间库的不满与愤怒 —— 我产生了一个近乎荒诞的执念：**我自己写一个
Go 时间库？**
>
> 这一切始于那个简陋、甚至可以说是有些 “丑陋” 的前身 `thru`，我决定对其系统化更新与重构。无数个灵感与想象如烟火般炸裂，才最终让它完成了跨越维度的蜕变。
>
> 我将其正式命名为：**Aeon**。在古老的哲学中，Aeon 代表着 “永恒” 与 “层叠的维度”。
>
> 我选择这个名字，是因为它代表了时间更本质的逻辑 —— 时间不是一条细长的直线，它是流动的、是可以被嵌套和穿透的宇宙。

# Aeon

线性计算？不，是容器索引！Aeon 重塑了 Go 时间法则，赋予你 **操控时间结构** 的绝对主权。

## 📦 安装

```bash
go get github.com/baagod/aeon
```

## 🧊 核心理念：容器

要掌握 Aeon，你只需要理解一个核心概念：**容器**。所有 **导航**，本质上都是在 **当前单位的父容器** 中进行索引 (从 0 开始)。

- **`GoYear(5)`**: 不是去公元 5 年，而是在 **本年代** 这个 **父容器** 中，**索引** 到第 5 年 ➜ `···5`。
- **`GoDecade(2)`**: 索引到 **本世纪** 第 2 个年代 ➜ `··2·`。
- **`GoCentury(0)`**: 索引到 **本千年** 第 "0" 个世纪 ➜ `·0··`。

*在现实世界中没有第 0 个世纪，这样设计是为了更简洁和直观表达。例如：`GoCentury(1)` ➜ `21··`*

## 🧭 导航矩阵

Aeon 的 API 设计是完全 **正交** 的，你只需要记住 **4 个动作**：

- `Go..` **全绝定位 (abs, abs..)：** `GoYear(5, 1)` ➜ 本年代第 5 年 1 月
- `Sh..` **全相偏移 (rel, rel..)：** `ShYear(1, 5)` ➜ 偏移 1 年 5 天
- `At..` **先定后移 (abs, rel, rel..)：** `AtYear(5, 1)` ➜ 定位到本年代的第 5 年再偏移 1 个月
- `In..` **先移后定 (rel, abs, abs..)：** `InYear(1, 5)` ➜ 明年 5 月

*`Sh` 系列方法默认值为 `1`，其余为 `0`。*

---

之后，配合 `Start/End` 前缀可定位到时间边界：

- `StartYear()`: 本年 **开始时间** (01-01 00:00:00...)
- `EndYear()`: 本年 **结束时间** (12-31 23:59:59...)

---

配合 6 个 **顶级** 方法进入 **绝对年份**：

1. `Go(2025, 2)` ➜ 2025-02
2. `At(2025, 2)` ➜ 定位到 2025 年后再偏移 2 个月
3. `Start(2025, 2)` ➜ 2025-02-01 00:00:00
4. `StartAt(2025, 1)` ➜ 定位到 2025 年后再偏移 1 个月的月初
5. `End(2025, 2)` ➜ 2025-02-28 23:59:59...
6. `EndAt(2025, 1)` ➜ 定位到 2025 年后再偏移 1 个月的月末

---

### ♾️ 级联参数

链式调用？不，是原子操作！所有方法均支持 **变长参数** 向下级联，参数像水流，**一行代码即可完成复杂定位**。

Aeon 会根据 **<u>入口单位</u>** 自动切换 4 种不同的级联序列：

1. **年序列 `Default`**：`世纪 ➜ 年代 ➜ 年 ➜ 月 ➜ 日 ➜ 时.. ➜ 纳秒`
2. **季度流 `Quarter`**：`季度 ➜ 月 (季内) ➜ 日 ➜ 时.. ➜ 纳秒`
3. **周序列 `Week`🦬**：`周 (智能上下文) ➜ 星期 ➜ 时.. ➜ 纳秒`

   这是 **变形金刚**！它根据传入的 **标志位** 自动切换形态：
   - `ISO`: 遵循 ISO 年周规则，获取本年第 n 个 ISO 年周。
   - `Full`: 完整周。从本月第 1 个周一开始。
   - `Ord`: 序数周。从本月 1 日开始的 7 天周。
   - `Default`: 日历周。遵循日历行视觉的周。
   
4. **星期流 `Weekday`**：`星期 ➜ 时.. ➜ 纳秒`

```go
// 相对偏移 1 年 3 月 5 日
ShYear(1, 3, 5)

// 2025 年 2 月最后一天 23 点整
Go(2025).StartMonth(2, -1, 23)

// 本年第 3 个季度最后一个月，最后 2 天结束时间
EndQuarter(3, -1, -2)

// 2025 年第 10 个 ISO 周一
Go(2025).StartWeek(aeon.ISO, 10, 1)

// 本月从 1 日开始的第 3 个 “七天周” 周五（本月第 3 个星期五）
StartWeek(aeon.Ord, 3, 5)

// 本月最后一个周五
GoWeek(aeon.Ord, -1, 5)

// 上个季度结束时间
EndShQuarter(-1)

// 本季度最后一个月 1 号
StartQuarter(0, -1, 1)

// 本周五 18 点 (下班时间)
StartWeekday(5, 18)

// 本月倒数第 3 天
StartDay(-3)

// 下周三下午 2 点
StartInWeek(1, 3, 14)

// 年度归档：年初/年末边界
StartYear() / EndYear()

// 下个月最后一天
EndInMonth(1, -1)
```

*负数不仅仅是减法，它是 **反向索引**，代表在 **“容器内倒数第 N 个”**。*

### 🛡️ 溢出保护

Aeon 的核心哲学是 **意图优先**，默认导航会保护 **“月及以上单位”** 溢出天数。

```go
base := NewDate(2025, 1, 31)
base.GoMonth(2) // 2025-02-28 (保护)
base.ShMonth(Overflow, 1) // 2025-03-03 (溢出)
base.ShMonth(1, 2) // 🛡️🦬 2025-03-02 (保护到 2-28 再加2天)

// 跨年：从闰年到平年
leap := NewDate(2024, 2, 29)
leap.ShYear(1) // 2025-02-28 (保护)
leap.ShYear(Overflow, 1) // 2025-03-01 (溢出：跨月)
leap.ShYear(4)           // 2028-02-29 (下一个闰年)
```
