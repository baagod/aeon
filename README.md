> 你或许觉得我疯了，没关系，我也这么认为。
>
> 记不清是从哪一刻开始了，也许是源于对 `time.Time` 和现有时间库的不满与愤怒 —— 我产生了一个近乎荒诞的执念：**我自己写一个
Go 时间库？**
>
> 这一切始于那个简陋、甚至可以说是有些 “丑陋” 的前身 `thru`，我决定对其系统化更新与重构。无数个灵感与想象如烟火般炸裂，才最终让它完成了跨越维度的蜕变。
>
> 我将其正式命名为：**Aeon**。在古老的哲学中，Aeon 代表着 “永恒” 与 “层叠的维度”。
>
> 我选择这个名字，是因为它代表了时间更本质的逻辑 —— 时间不是一条细长的直线，它是流动的、是可以被嵌套和穿透的宇宙。

# Aeon

**Aeon** 是一个试图重塑 Go 语言时间操作体验的库。它不教你 “拨动时钟”，而是教你如何 **操纵时间结构**。

## 📦 安装

```bash
go get github.com/baagod/aeon
```

## 🧊 核心理念：容器

要掌握 Aeon，你只需要理解一个核心概念：**容器**。所有 **导航**，本质上都是在 **当前单位的父容器** 中进行索引 (从 0 开始)。

- **`GoYear(5)`**: 不是去公元 5 年，而是在 **本年代** 这个 **父容器** 中，**索引** 到第 5 年 ➜ `···5`。
- **`GoDecade(2)`**: 索引到 **本世纪** 第 2 个年代 ➜ `··2·`。
- **`GoCentury(0)`**: 索引到 **本千年** 第 "0" 个世纪 ➜ `·0··`。

*在现实世界中没有第 0 个世纪，这样设计是为了更简洁和直观表达。例如：`GoCentury(1)` ➜ `21··`*

## 🧭 导航矩阵

Aeon 的 API 设计是完全 **正交** 的，你只需要记住 **4 个动作**：

- `Go..` **全绝定位 (abs, abs..)：** `GoYear(5， 1)` ➜ 本年代第 5 年 1 月
- `Sh..` **全相偏移 (rel, rel..)：** `ShYear(1, 5)` ➜ 偏移 1 年 5 天
- `At..` **先定后移 (abs, rel, rel..)：** `AtYear(5, 1)` ➜ 定位到本年代的第 5 年再偏移 1 个月
- `In..` **先移后定 (rel, abs, abs..)：** `InYear(1, 5)` ➜ 明年 5 月

*`Sh` 系列方法默认值为 `1`，其余为 `0`。*

---

之后，配合 `Start/End` 前缀可定位到时间边界：

- `StartYear()`: 本年 **开始时间** (01-01 00:00:00...)
- `EndYear()`: 本年 **结束时间** (12-31 23:59:59...)

---

配合 6 个 **顶级** 方法进入 **绝对年份**：

1. `Go(2025, 2)` ➜ 2025-02
2. `At(2025, 2)` ➜ 定位到 2025 年后再偏移 2 个月
3. `Start(2025, 2)` ➜ 2025-02-01 00:00:00
4. `StartAt(2025, 1)` ➜ 定位到 2025 年后再偏移 1 个月的月初
5. `End(2025, 2)` ➜ 2025-02-28 23:59:59...
6. `EndAt(2025, 1)` ➜ 定位到 2025 年后再偏移 1 个月的月末

---

### ♾️ 级联导航

链式调用？不，是原子操作！`GoYear(5, 2, 1)` ➜ 2025-02-01。

所有方法均支持 **变长参数** 向下级联，参数像水流，**一行代码即可完成复杂定位**：

```go
// 2025 年 2 月最后一天 23 点整
t.Aeon().Go(2025).StartMonth(2, -1, 23)

// 本年第 3 个季度最后一个月，最后 2 天结束时间
t.EndQuarter(3, -1, -2)

// 本周五 18 点 (下班时间)
t.StartWeekday(5, 18)

// 2025 年第 10 个 ISO 周一
t.Go(2025).StartWeek(aeon.ISO, 10, 1)

// 本月从 1 日开始第 3 个 “七天周” 的周五（本月第 3 个星期五）
t.StartWeek(aeon.Ord, 3, 5)
```

Aeon 会根据 **<u>入口单位</u>** 自动切换 3 种不同的级联序列。

1. **年序列 `Year`**：`世纪 ➜ 年代 ➜ 年 ➜ 月 ➜ 日 ➜ 时.. ➜ 纳秒`
2. **季序列 `Quarter`**：`季度 ➜ 月 (季内) ➜ 日 ➜ 时.. ➜ 纳秒`
3. **周序列 `Week`**：`周 (月内) ➜ 星期 ➜ 时.. ➜ 纳秒`

#### 负数索引

在级联中，负数参数不仅仅是减法，它是 **反向索引**，代表在 “容器内倒数第 N 个”。

这让你无需关心大月小月或平闰年，直接定位 “尾部”。

### 🛡️ 溢出保护

Aeon 默认拦截非预期的日期溢出，但也赋予你打破规则的权利。

```go
t := aeon.NewDate(2025, 1, 31)

// 默认行为：智能截断
t.GoMonth(2) // -> 2月28日 (自动截断)

// 显式溢出：打破容器限制
t.GoMonth(aeon.Overflow, 2) // -> 3月3日 (2月28 + 3天)
```

## 🛠️ 深度技术

Aeon 不仅追求语义的优雅，更追求极致的性能。

- **Zero Alloc**: 核心导航逻辑 **0 内存分配**。
- **Bitmask Protocol**: 我们将 `ISO`, `Overflow` 等配置压缩进了 `int` 参数的高位，避免了创建配置对象的开销。
- **Nano Precision**: 全链路支持纳秒级对齐，`End*` 方法精准覆盖到 `.999999999`，确保数据库范围查询不漏数据。
